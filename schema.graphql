"used in Vote"
enum SignedMsgType {
  SIGNED_MSG_TYPE_UNKNOWN
  SIGNED_MSG_TYPE_PREVOTE
  SIGNED_MSG_TYPE_PRECOMMIT
  SIGNED_MSG_TYPE_PROPOSAL
}

"BlockIdFlag indicates which BlockID the signature is for"
enum BlockIDFlag {
  BLOCK_ID_FLAG_UNKNOWN
  BLOCK_ID_FLAG_ABSENT
  BLOCK_ID_FLAG_COMMIT
  BLOCK_ID_FLAG_NIL
}

"EventData"
type EventData @entity {
  id: ID!
  event: Event
  block: EventList
}

"EventList"
type EventList @entity {
  id: ID!
  new_block: EventBlock
  transaction: [EventTx!]
  validator_set_updates: EventValidatorSetUpdates
}

"Reward"
type Reward @entity {
  id: ID!
  amount: String
  validator: String
}

type Block @entity {
  id: ID!
  header: Header
  data: Data
  evidence: EvidenceList
  last_commit: Commit
}

type BlockID @entity {
  id: ID!
  hash: Bytes
  part_set_header: PartSetHeader
}

type BlockParams @entity {
  id: ID!
  "Note: must be greater than 0"
  max_bytes: BigInt
  "Note: must be greater or equal to -1"
  max_gas: BigInt
}

type Commit @entity {
  id: ID!
  "must be > 0"
  height: BigInt
  "must be > 0"
  round: Int
  block_id: BlockID
  signatures: [CommitSig!]
}

type CommitSig @entity {
  id: ID!
  "must match those in the enum above"
  block_id_flag: BlockIDFlag
  "hash 256 20 bytes - this is the first 20 characters of a 32-byte key - SHA256(pubkey)[:20]"
  validator_address: Bytes
  timestamp: Timestamp
  "length should be > 0 and < 64"
  signature: Bytes
}

type Consensus @entity {
  id: ID!
  block: BigInt
  app: BigInt
}

type ConsensusParams @entity {
  id: ID!
  block: BlockParams
  evidence: EvidenceParams
  validator: ValidatorParams
  version: VersionParams
}

type Data @entity {
  id: ID!
  txs: [Bytes!]
}

type Duration @entity {
  id: ID!
  seconds: BigInt
  nanos: Int
}

type DuplicateVoteEvidence @entity {
  id: ID!
  vote_a: EventVote
  vote_b: EventVote
  total_voting_power: BigInt
  validator_power: BigInt
  timestamp: Timestamp
}

type Event @entity {
  id: ID!
  event_type: String
  attributes: [EventAttribute!]
}

type EventAttribute @entity {
  id: ID!
  key: String
  value: String
  "nondeterministic"
  index: Boolean
}

type EventBlock @entity {
  id: ID!
  block: Block
  "not present in v0.34.13"
  block_id: BlockID
  result_begin_block: ResponseBeginBlock
  result_end_block: ResponseEndBlock
}

type EventTx @entity {
  id: ID!
  tx_result: TxResult
}

type EventValidatorSetUpdates @entity {
  id: ID!
  validator_updates: [Validator!]
}

type EventVote @entity {
  id: ID!
  "should be present in the enum at the top of this file"
  event_vote_type: SignedMsgType
  "must be > 0"
  height: BigInt
  "must be > 0"
  round: Int
  block_id: BlockID
  timestamp: Timestamp
  "hash with a length of 20"
  validator_address: Bytes
  validator_index: Int
  "hash length should be >0 and <64"
  signature: Bytes
}

type Evidence @entity {
  id: ID!
  duplicate_vote_evidence: DuplicateVoteEvidence
  light_client_attack_evidence: LightClientAttackEvidence
}

type EvidenceList @entity {
  id: ID!
  evidence: [Evidence!]
}

type EvidenceParams @entity {
  id: ID!
  max_age_num_blocks: BigInt
  max_age_duration: Duration
  "Default is 1048576 or 1MB"
  max_bytes: BigInt
}

type Header @entity {
  id: ID!
  version: Consensus
  chain_id: String
  height: BigInt
  time: Timestamp
  last_block_id: BlockID
  "hash 256 32 bytes"
  last_commit_hash: Bytes
  "hash 256 32 bytes"
  data_hash: Bytes
  "hash 256 32 bytes"
  validators_hash: Bytes
  "hash 256 32 bytes"
  next_validators_hash: Bytes
  "hash 256 32 bytes"
  consensus_hash: Bytes
  "determined by application, not a fixed length"
  app_hash: Bytes
  "hash 256 32 bytes - first block will be results of an empty hash"
  last_results_hash: Bytes
  "hash sha256 32 bytes"
  evidence_hash: Bytes
  "hash 256 20 bytes - this is the first 20 characters of a 32-byte key - SHA256(pubkey)[:20]"
  proposer_address: Bytes
}

type LightBlock @entity {
  id: ID!
  "cannot be nil"
  signed_header: SignedHeader
  "cannot be nil"
  validator_set: ValidatorSet
}

type LightClientAttackEvidence @entity {
  id: ID!
  conflicting_block: LightBlock
  common_height: BigInt
  byzantine_validators: [Validator!]
  total_voting_power: BigInt
  timestamp: Timestamp
}

type PublicKey @entity {
  id: ID!
  ed25519: Bytes
  secp256k1: Bytes
}

type PartSetHeader @entity {
  id: ID!
  total: BigInt
  "hash 256 32 bytes"
  hash: Bytes
}

type ResponseBeginBlock @entity {
  id: ID!
  events: [Event!]
}

type ResponseEndBlock @entity {
  id: ID!
  validator_updates: [ValidatorUpdate!]
  consensus_param_updates: ConsensusParams
  events: [Event!]
}

type ResponseDeliverTx @entity {
  id: ID!
  code: BigInt
  data: Bytes
  log: String
  info: String
  gas_wanted: BigInt
  gas_used: BigInt
  events: [Event!]
  codespace: String
}

type SignedHeader @entity {
  id: ID!
  header: Header
  commit: Commit
}

type Timestamp @entity {
  id: ID!
  seconds: BigInt
  nanos: Int
}

type TxResult @entity {
  id: ID!
  height: BigInt
  index: BigInt
  tx: Bytes
  result: ResponseDeliverTx
}

type Validator @entity {
  id: ID!
  address: Bytes
  "must be > 0"
  pub_key: PublicKey
  voting_power: BigInt
  proposer_priority: BigInt
}

type ValidatorParams @entity {
  id: ID!
  pub_key_types: [String!]
}

type ValidatorSet @entity {
  id: ID!
  "cannot be empty or nil"
  validators: [Validator!]
  "cannot be nil"
  proposer: Validator
  total_voting_power: BigInt
}

type ValidatorUpdate @entity {
  id: ID!
  address: Bytes
  pub_key: PublicKey
  power: BigInt
}

type VersionParams @entity {
  id: ID!
  app_version: BigInt
}

enum SignMode {
  SIGN_MODE_UNSPECIFIED
  SIGN_MODE_DIRECT
  SIGN_MODE_TEXTUAL
  SIGN_MODE_DIRECT_AUX
  SIGN_MODE_LEGACY_AMINO_JSON
}

type Tx @entity {
  id: ID!
  body: TxBody
  auth_info: AuthInfo
}

type TxRaw @entity {
  id: ID!
  body_bytes: Bytes
  auth_info_bytes: Bytes
  signatures: [Bytes!]
}

type TxBody @entity {
  id: ID!
  messages: [Any!]
  memo: String
  timeout_height: BigInt
  extension_options: [Any!]
  non_critical_extension_options: [Any!]
}

type AuthInfo @entity {
  id: ID!
  signer_infos: [SignerInfo!]
  fee: Fee
  tip: Tip
}

type SignerInfo @entity {
  id: ID!
  public_key: Any
  mode_info: ModeInfo
  sequence: BigInt
}

type ModeInfo @entity {
  id: ID!
  single: Single
  multi: Multi
}

type Single @entity {
  id: ID!
  mode: SignMode
}

type Multi @entity {
  id: ID!
  bitarray: CompactBitArray
  mode_infos: [ModeInfo!]
}

"cosmos.crypto.multisig.v1beta1.CompactBitArray"
type CompactBitArray @entity {
  id: ID!
  extra_bits_stored: BigInt
  elems: Bytes
}

type Fee @entity {
  id: ID!
  amount: [Coin!]
  gas_limit: BigInt
  payer: String
  granter: String
}

type Tip @entity {
  id: ID!
  amount: [Coin!]
  tipper: String
}

type Coin @entity {
  id: ID!
  denom: String
  amount: String
}

type Any @entity {
  id: ID!
  type_url: String
  value: Bytes
}

type PubKey @entity {
  id: ID!
  key: Bytes
}

enum State {
  STATE_UNINITIALIZED_UNSPECIFIED
  STATE_INIT
  STATE_TRYOPEN
  STATE_OPEN
  STATE_CLOSED
}

enum Order {
  ORDER_NONE_UNSPECIFIED
  ORDER_UNORDERED
  ORDER_ORDERED
}

enum VoteOption {
  VOTE_OPTION_UNSPECIFIED
  VOTE_OPTION_YES
  VOTE_OPTION_ABSTAIN
  VOTE_OPTION_NO
  VOTE_OPTION_NO_WITH_VETO
}

type MsgSend @entity {
  id: ID!
  from_address: String
  to_address: String
  amount: [Coin!]
}

type MsgMultiSend @entity {
  id: ID!
  inputs: [Input!]
  outputs: [Output!]
}

type MsgVerifyInvariant @entity {
  id: ID!
  sender: String
  invariant_module_name: String
  invariant_route: String
}

type MsgSetWithdrawAddress @entity {
  id: ID!
  delegator_address: String
  withdraw_address: String
}

type MsgWithdrawDelegatorReward @entity {
  id: ID!
  delegator_address: String
  validator_address: String
}

type MsgWithdrawValidatorCommission @entity {
  id: ID!
  validator_address: String
}

type MsgFundCommunityPool @entity {
  id: ID!
  amount: [Coin!]
  depositor: String
}

type MsgSubmitEvidence @entity {
  id: ID!
  submitter: String
  evidence: Any
}

type MsgSubmitProposal @entity {
  id: ID!
  content: Any
  initial_deposit: [Coin!]
  proposer: String
}

type MsgVote @entity {
  id: ID!
  proposal_id: BigInt
  voter: String
  option: VoteOption
}

type MsgDeposit @entity {
  id: ID!
  proposal_id: BigInt
  depositor: String
  amount: [Coin!]
}

type MsgUnjail @entity {
  id: ID!
  validator_addr: String
}

type MsgCreateValidator @entity {
  id: ID!
  description: Description
  commission: CommissionRates
  min_self_delegation: String
  delegator_address: String
  validator_address: String
  pubkey: Any
  value: Coin
}

type MsgEditValidator @entity {
  id: ID!
  description: Description
  validator_address: String
  commission_rate: String
  min_self_delegation: String
}

type MsgDelegate @entity {
  id: ID!
  delegator_address: String
  validator_address: String
  amount: Coin
}

type MsgBeginRedelegate @entity {
  id: ID!
  delegator_address: String
  validator_src_address: String
  validator_dst_address: String
  amount: Coin
}

type MsgUndelegate @entity {
  id: ID!
  delegator_address: String
  validator_address: String
  amount: Coin
}

type MsgCreateVestingAccount @entity {
  id: ID!
  from_address: String
  to_address: String
  amount: Coin
  end_time: BigInt
  delayed: Boolean
}

type MsgTransfer @entity {
  id: ID!
  source_port: String
  source_channel: String
  token: Coin
  sender: String
  receiver: String
  timeout_height: Height
  timeout_timestamp: BigInt
}

type MsgChannelOpenInit @entity {
  id: ID!
  port_id: String
  channel: Channel
  signer: String
}

type MsgChannelOpenTry @entity {
  id: ID!
  port_id: String
  previous_channel_id: String
  channel: Channel
  counterparty_version: String
  proof_init: Bytes
  proof_height: Height
  signer: String
}

type MsgChannelOpenAck @entity {
  id: ID!
  port_id: String
  channel_id: String
  counterparty_channel_id: String
  counterparty_version: String
  proof_try: Bytes
  proof_height: Height
  signer: String
}

type MsgChannelOpenConfirm @entity {
  id: ID!
  port_id: String
  channel_id: String
  proof_ack: Bytes
  proof_height: Height
  signer: String
}

type MsgChannelCloseInit @entity {
  id: ID!
  port_id: String
  channel_id: String
  signer: String
}

type MsgChannelCloseConfirm @entity {
  id: ID!
  port_id: String
  channel_id: String
  proof_init: Bytes
  proof_height: Height
  signer: String
}

type MsgRecvPacket @entity {
  id: ID!
  packet: Packet
  proof_commitment: Bytes
  proof_height: Height
  signer: String
}

type MsgTimeout @entity {
  id: ID!
  packet: Packet
  proof_unreceived: Bytes
  proof_height: Height
  next_sequence_recv: BigInt
  signer: String
}

type MsgTimeoutOnClose @entity {
  id: ID!
  packet: Packet
  proof_unreceived: Bytes
  proof_close: Bytes
  proof_height: Height
  next_sequence_recv: BigInt
  signer: String
}

type MsgAcknowledgement @entity {
  id: ID!
  packet: Packet
  acknowledgement: Bytes
  proof_acked: Bytes
  proof_height: Height
  signer: String
}

type MsgCreateClient @entity {
  id: ID!
  client_state: Any
  consensus_state: Any
  signer: String
}

type MsgUpdateClient @entity {
  id: ID!
  client_id: String
  header: Any
  signer: String
}

type MsgUpgradeClient @entity {
  id: ID!
  client_id: String
  client_state: Any
  consensus_state: Any
  proof_upgrade_client: Bytes
  proof_upgrade_consensus_state: Bytes
  signer: String
}

type MsgSubmitMisbehaviour @entity {
  id: ID!
  client_id: String
  misbehaviour: Any
  signer: String
}

type MsgConnectionOpenInit @entity {
  id: ID!
  client_id: String
  counterparty: ConnectionCounterparty
  version: ConnectionVersion
  delay_period: BigInt
  signer: String
}

type MsgConnectionOpenTry @entity {
  id: ID!
  client_id: String
  previous_connection_id: String
  client_state: Any
  counterparty: ConnectionCounterparty
  delay_period: BigInt
  counterparty_versions: [ConnectionVersion!]
  proof_height: Height
  proof_init: Bytes
  proof_client: Bytes
  proof_consensus: Bytes
  consensus_height: Height
  signer: String
}

type MsgConnectionOpenAck @entity {
  id: ID!
  connection_id: String
  counterparty_connection_id: String
  version: ConnectionVersion
  client_state: Any
  proof_height: Height
  proof_try: Bytes
  proof_client: Bytes
  proof_consensus: Bytes
  consensus_height: Height
  signer: String
}

type MsgConnectionOpenConfirm @entity {
  id: ID!
  connection_id: String
  proof_ack: Bytes
  proof_height: Height
  signer: String
}

type Channel @entity {
  id: ID!
  state: State
  ordering: Order
  counterparty: ChannelCounterparty
  connection_hops: [String!]
  version: String
}

type ChannelCounterparty @entity {
  id: ID!
  port_id: String
  channel_id: String
}

type CommissionRates @entity {
  id: ID!
  rate: String
  max_rate: String
  max_change_rate: String
}

type ConnectionCounterparty @entity {
  id: ID!
  client_id: String
  connection_id: String
  prefix: MerklePrefix
}

type ConnectionVersion @entity {
  id: ID!
  identifier: String
  features: [String!]
}

type Description @entity {
  id: ID!
  moniker: String
  identity: String
  website: String
  security_contact: String
  details: String
}

type Height @entity {
  id: ID!
  revision_number: BigInt
  revision_height: BigInt
}

type Input @entity {
  id: ID!
  address: String
  coins: [Coin!]
}

type Output @entity {
  id: ID!
  address: String
  coins: [Coin!]
}

type MerklePrefix @entity {
  id: ID!
  key_prefix: Bytes
}

type Packet @entity {
  id: ID!
  sequence: BigInt
  source_port: String
  source_channel: String
  destination_port: String
  destination_channel: String
  data: Bytes
  timeout_height: Height
  timeout_timestamp: BigInt
}
