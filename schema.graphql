"used in Vote"
enum SignedMsgType {
  SIGNED_MSG_TYPE_UNKNOWN
  SIGNED_MSG_TYPE_PREVOTE
  SIGNED_MSG_TYPE_PRECOMMIT
  SIGNED_MSG_TYPE_PROPOSAL
}

"BlockIdFlag indicates which BlockID the signature is for"
enum BlockIDFlag {
  BLOCK_ID_FLAG_UNKNOWN
  BLOCK_ID_FLAG_ABSENT
  BLOCK_ID_FLAG_COMMIT
  BLOCK_ID_FLAG_NIL
}

type EventList @entity {
  id: ID!
  newblock: EventBlock
  transaction: [EventTx!]
  validatorsetupdates: EventValidatorSetUpdates
}

"EventBlock"
type EventBlock @entity {
  id: ID!
  block: Block
  "not present in v0.34.13"
  block_id: BlockID
  result_begin_block: ResponseBeginBlock
  result_end_block: ResponseEndBlock
}

type ResponseBeginBlock @entity {
  id: ID!
  events: [Event!]
}

type ResponseEndBlock @entity {
  id: ID!
  validator_updates: [Validator!]
  consensus_param_updates: ConsensusParams
  events: [Event!]
}

type ConsensusParams @entity {
  id: ID!
  block: Block
  evidence: Evidence
  validator: Validator
  version: Version
}

type Version @entity {
  id: ID!
  app_version: BigInt
}

type Block @entity {
  id: ID!
  header: Header
  data: Data
  evidence: EvidenceList
  last_commit: Commit
}

type Commit @entity {
  id: ID!
  "must be > 0"
  height: BigInt
  "must be > 0"
  round: Int
  block_id: BlockID
  "must be > 0"
  signatures: [CommitSig!]
}

type CommitSig @entity {
  id: ID!
  "must match those in the enum above"
  block_id_flag: BlockIDFlag
  "hash 256 20 bytes - this is the first 20 characters of a 32-byte key - SHA256(pubkey)[:20]"
  validator_address: Address
  timestamp: Timestamp
  "length should be > 0 and < 64"
  signature: Bytes
}

type EventBlockHeader @entity {
  id: ID!
  header: Header
  num_txs: BigInt
  result_begin_block: ResponseBeginBlock
  result_end_block: ResponseEndBlock
}

type Header @entity {
  id: ID!
  version: Consensus
  chain_id: String
  height: BigInt
  time: Timestamp
  last_block_id: BlockID
  "hash 256 32 bytes"
  last_commit_hash: Bytes
  "hash 256 32 bytes"
  data_hash: Bytes
  "hash 256 32 bytes"
  validators_hash: Bytes
  "hash 256 32 bytes"
  next_validators_hash: Bytes
  "hash 256 32 bytes"
  consensus_hash: Bytes
  "determined by application, not a fixed length"
  app_hash: Bytes
  "hash 256 32 bytes - first block will be results of an empty hash"
  last_results_hash: Bytes
  "hash sha256 32 bytes"
  evidence_hash: Bytes
  "hash 256 20 bytes - this is the first 20 characters of a 32-byte key - SHA256(pubkey)[:20]"
  proposer_address: Address
}

type Consensus @entity {
  id: ID!
  block: BigInt
  app: BigInt
}

type BlockID @entity {
  id: ID!
  hash: Bytes
  part_set_header: PartSetHeader
}

type PartSetHeader @entity {
  id: ID!
  total: BigInt
  "hash 256 32 bytes"
  hash: Bytes
}

type Data @entity {
  id: ID!
  txs: [Bytes!]
}

type Evidence @entity {
  id: ID!
  duplicate_vote_evidence: DuplicateVoteEvidence
  light_client_attack_evidence: LightClientAttackEvidence
}

type DuplicateVoteEvidence @entity {
  id: ID!
  vote_a: EventVote
  vote_b: EventVote
  total_voting_power: BigInt
  validator_power: BigInt
  timestamp: Timestamp
}

"EventTx"
type EventTx @entity {
  id: ID!
  TxResult: TxResult
}

"EventVote"
type EventVote @entity {
  id: ID!
  "should be present in the enum at the top of this file"
  eventvotetype: SignedMsgType
  "must be > 0"
  height: BigInt
  "must be > 0"
  round: Int
  block_id: BlockID
  timestamp: Timestamp
  "hash with a length of 20"
  validator_address: Address
  validator_index: Int
  "hash length should be >0 and <64"
  signature: Bytes
}

type LightClientAttackEvidence @entity {
  id: ID!
  conflicting_block: LightBlock
  common_height: BigInt
  byzantine_validators: [Validator!]
  total_voting_power: BigInt
  timestamp: Timestamp
}

type LightBlock @entity {
  id: ID!
  "cannot be nil"
  signed_header: SignedHeader
  "cannot be nil"
  validator_set: ValidatorSet
}

type ValidatorSet @entity {
  id: ID!
  "cannot be empty of nil"
  validators: [Validator!]
  "cannot be nil"
  proposer: Validator
  total_voting_power: BigInt
}

type SignedHeader @entity {
  id: ID!
  header: Header
  commit: Commit
}

type EvidenceList @entity {
  id: ID!
  evidence: [Evidence!]
}

type Validator @entity {
  id: ID!
  address: Bytes
  "must be >0"
  pub_key: PublicKey
  voting_power: BigInt
  proposer_priority: BigInt
}

type PublicKey @entity {
  id: ID!
  ed25519: Bytes
  secp256k1: Bytes
  sr25519: Bytes
}

type TxResult @entity {
  id: ID!
  height: BigInt
  index: BigInt
  tx: Bytes
  result: ResponseDeliverTx
}

type ResponseDeliverTx @entity {
  id: ID!
  code: BigInt
  data: Bytes
  log: String
  info: String
  gas_wanted: BigInt
  gas_used: BigInt
  events: [Event!]
  codespace: String
}

type Event @entity {
  id: ID!
  eventtype: String
  attributes: [EventAttribute!]
}

type EventAttribute @entity {
  id: ID!
  key: String
  value: String
  index: Boolean
}

type Address @entity {
  id: ID!
  address: Bytes
}

"EventValidatorSetUpdates"
type EventValidatorSetUpdates @entity {
  id: ID!
  validator_updates: [Validator!]
}

type Timestamp @entity {
  id: ID!
  seconds: BigInt
  nanos: Int
}

type fig @entity {
  id: ID!
}
